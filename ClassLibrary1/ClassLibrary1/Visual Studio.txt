/ClassLibrary1/Ability_ToggleKagune.cs
========================================
﻿using RimWorld;
using Verse;
using System.Linq;

namespace TokyoGhoulMod
{
    public class Ability_ToggleKagune : Ability
    {
        public override bool Activate(LocalTargetInfo target, LocalTargetInfo dest)
        {
            base.Activate(target, dest);

            // Превращаем Release_Ukaku в Hediff_Ukaku
            string hediffDefName = this.def.defName.Replace("Release_", "Hediff_");
            HediffDef kaguneHediffDef = HediffDef.Named(hediffDefName);
            HediffDef kakuganDef = DefDatabase<HediffDef>.GetNamed("Kakugan", false);

            if (kaguneHediffDef == null) return false;

            Hediff existing = pawn.health.hediffSet.GetFirstHediffOfDef(kaguneHediffDef);

            if (existing != null)
            {
                // Если уже есть - снимаем
                pawn.health.RemoveHediff(existing);

                if (kakuganDef != null)
                {
                    Hediff kakuganHediff = pawn.health.hediffSet.GetFirstHediffOfDef(kakuganDef);
                    if (kakuganHediff != null) pawn.health.RemoveHediff(kakuganHediff);
                }
            }
            else
            {
                // Если нет - снимаем другие типы и надеваем этот
                RemoveExistingKagunes(pawn);
                pawn.health.AddHediff(kaguneHediffDef);
                if (kakuganDef != null) pawn.health.AddHediff(kakuganDef);
            }

            // Обновление
            if (pawn.meleeVerbs != null) pawn.meleeVerbs.Notify_PawnDespawned();
            pawn.Drawer.renderer.SetAllGraphicsDirty();

            return true;
        }

        private void RemoveExistingKagunes(Pawn p)
        {
            // Список всех возможных хедиффов кагуне для удаления при переключении
            string[] tags = { "Ukaku", "Koukaku", "Rinkaku", "Bikaku" };
            var toRemove = p.health.hediffSet.hediffs
                .Where(h => tags.Any(tag => h.def.defName == "Hediff_" + tag))
                .ToList();

            foreach (var h in toRemove) p.health.RemoveHediff(h);
        }

        public override AcceptanceReport CanCast
        {
            get
            {
                AcceptanceReport report = base.CanCast;
                if (!report.Accepted) return report;

                if (!pawn.health.hediffSet.HasHediff(DefDatabase<HediffDef>.GetNamed("Kakuho", false)))
                    return new AcceptanceReport("Отсутствует какухо");

                return true;
            }
        }
    }
}

/ClassLibrary1/Ability_UkakuFire.cs
========================================
﻿using RimWorld;
using Verse;

namespace TokyoGhoulMod
{
    public class Ability_UkakuFire : Ability
    {
        public override AcceptanceReport CanCast
        {
            get
            {
                AcceptanceReport report = base.CanCast;
                if (!report.Accepted) return report;

                // Проверяем, выпущено ли Укаку
                if (!pawn.health.hediffSet.HasHediff(HediffDef.Named("Hediff_Ukaku")))
                {
                    return new AcceptanceReport("Нужно активировать Укаку");
                }
                return true;
            }
        }

        public override bool Activate(LocalTargetInfo target, LocalTargetInfo dest)
        {
            base.Activate(target, dest); // Важно вызвать базу для запуска снаряда

            Gene_RCCells gene = pawn.genes?.GetFirstGeneOfType<Gene_RCCells>();
            if (gene != null) gene.Value -= 0.03f;

            return true;
        }
    }
}

/ClassLibrary1/GeneGizmo_RCCells.cs
========================================
﻿using RimWorld;
using Verse;
using UnityEngine;
using System.Collections.Generic;

namespace TokyoGhoulMod
{
    public class GeneGizmo_RCCells : GeneGizmo_Resource
    {
        // Конструктор, принимающий 4 параметра
        public GeneGizmo_RCCells(Gene_Resource gene, List<IGeneResourceDrain> drainDefs, Color barColor, Color barHighlightColor)
            : base(gene, drainDefs, barColor, barHighlightColor)
        {
        }

        // Обязательные поля для слайдеров в 1.6
        protected override bool DraggingBar { get; set; }

        protected override string GetTooltip()
        {
            return "Запас RC-клеток. Необходим для активации кагуне и регенерации.";
        }
    }
}

/ClassLibrary1/Gene_RCCells.cs
========================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using RimWorld;
using UnityEngine;
using Verse;

namespace TokyoGhoulMod
{
    public class Gene_RCCells : Gene_Resource
    {
        private const float DaysToStarve = 15f;
        private const float PassiveDrainPerDay = 1f / DaysToStarve;
        private const float KaguneDrainMultiplier = 15f;

        public override float InitialResourceMax => 1f;
        protected override Color BarColor => new Color(0.75f, 0f, 0f);
        protected override Color BarHighlightColor => new Color(1f, 0.2f, 0.2f);
        public override float MinLevelForAlert => 0.15f;
        public override string ResourceLabel => "RC-клетки";

        // Пороги для отображения на шкале (заменяет отсутствующий resourceGizmoThresholds)
        private static readonly List<float> Thresholds = new List<float> { 0.2f, 0.5f, 0.8f };

        public override IEnumerable<Gizmo> GetGizmos()
        {
            // Сначала возвращаем базовые гизмо, пропуская стандартную шкалу ресурса
            foreach (Gizmo gizmo in base.GetGizmos())
            {
                if (!(gizmo is GeneGizmo_Resource)) yield return gizmo;
            }

            // Добавляем нашу кастомную шкалу
            if (pawn.IsColonistPlayerControlled)
            {
                // Аргументы: (сам ген, список потребителей ресурса, основной цвет, цвет подсветки)
                // Мы передаем null в качестве списка потребителей, так как RC-клетки тратит код, а не другие гены.
                yield return new GeneGizmo_RCCells(this, null, BarColor, BarHighlightColor);
            }
        }

        public override void Tick()
        {
            base.Tick();

            // Делаем расчеты раз в 100 тиков для производительности
            if (pawn.IsHashIntervalTick(100))
            {
                // Проверяем наличие хедиффа активного кагуне
                // Рекомендую закэшировать деф в GhoulDefOf, чтобы не искать по имени каждый раз
                HediffDef rinkakuDef = DefDatabase<HediffDef>.GetNamed("KaguneRinkaku", false);
                bool isActive = rinkakuDef != null && pawn.health.hediffSet.HasHediff(rinkakuDef);

                // 1. Управляем визуалом глаз
                ManageKakugan(isActive);

                // 2. Рассчитываем и вычитаем расход RC-клеток
                float dailyDrain = isActive ? (PassiveDrainPerDay * KaguneDrainMultiplier) : PassiveDrainPerDay;
                // (dailyDrain / 60000) - расход в 1 тик. Умножаем на 100, так как проверяем раз в 100 тиков.
                Value -= (dailyDrain / 60000f) * 100f;

                // 3. ОБЯЗАТЕЛЬНО вызываем проверку эффектов (отключение кагуне при 0 RC и берсерк)
                UpdateStatusEffects(isActive);
            }
        }

        // Остальные методы (ManageKakugan, UpdateStatusEffects, PostAdd) остаются без изменений
        private void ManageKakugan(bool isKaguneActive)
        {
            bool shouldHave = isKaguneActive || pawn.InMentalState;
            HediffDef kakuganDef = DefDatabase<HediffDef>.GetNamed("Kakugan", false);
            if (kakuganDef == null) return;
            bool currentlyHas = pawn.health.hediffSet.HasHediff(kakuganDef);

            if (shouldHave && !currentlyHas)
            {
                var eyes = pawn.RaceProps.body.AllParts.Where(p => p.def == BodyPartDefOf.Eye);
                foreach (var part in eyes) pawn.health.AddHediff(kakuganDef, part);
                pawn.Drawer.renderer.SetAllGraphicsDirty();
            }
            else if (!shouldHave && currentlyHas)
            {
                pawn.health.hediffSet.hediffs.RemoveAll(x => x.def == kakuganDef);
                pawn.Drawer.renderer.SetAllGraphicsDirty();
            }
        }

        private void UpdateStatusEffects(bool isKaguneActive)
        {
            if (pawn == null || !pawn.Spawned) return;
            if (pawn.needs.food != null && pawn.needs.food.CurLevel <= 0.01f && Value > 0.1f)
            {
                if (!pawn.InMentalState && !IsDeathresting(pawn) && Rand.Value < 0.1f)
                {
                    pawn.mindState.mentalStateHandler.TryStartMentalState(MentalStateDefOf.Berserk, "Голод гуля", true);
                }
            }
            if (Value <= 0 && isKaguneActive)
            {
                Hediff kagu = pawn.health.hediffSet.GetFirstHediffOfDef(DefDatabase<HediffDef>.GetNamed("KaguneRinkaku"));
                if (kagu != null) pawn.health.RemoveHediff(kagu);
            }
        }

        private bool IsDeathresting(Pawn p) => ModsConfig.BiotechActive && p.Deathresting;

        public override void PostAdd()
        {
            base.PostAdd();
            if (!pawn.health.hediffSet.HasHediff(DefDatabase<HediffDef>.GetNamed("Kakuho", false)))
                pawn.health.AddHediff(DefDatabase<HediffDef>.GetNamed("Kakuho"), pawn.RaceProps.body.corePart);
            Value = 0.5f;
        }
    }
}

/ClassLibrary1/GhoulDefOf.cs
========================================
﻿using RimWorld;
using Verse;

namespace TokyoGhoulMod
{
    [DefOf]
    public static class GhoulDefOf
    {
        public static HediffDef TG_RinkakuKagune;

        public static XenotypeDef TG_Ghoul;

        static GhoulDefOf()
        {
            DefOfHelper.EnsureInitializedInCtor(typeof(GhoulDefOf));
        }
    }
}

/ClassLibrary1/Hediff_KaguneRinkaku.cs
========================================
﻿using RimWorld;
using Verse;

namespace TokyoGhoulMod
{
    public class Hediff_KaguneRinkaku : HediffWithComps
    {
        private const int CheckInterval = 200; // Проверка примерно каждые 3 секунды игрового времени

        public override void Tick()
        {
            base.Tick();

            if (pawn.IsHashIntervalTick(CheckInterval))
            {
                // 1. Получаем доступ к гену RC-клеток
                Gene_RCCells gene = pawn.genes?.GetFirstGeneOfType<Gene_RCCells>();

                // 2. Проверка на наличие клеток и их потребление
                if (gene == null || gene.Value <= 0.005f) // Небольшой порог, чтобы не уходить в минус
                {
                    Messages.Message("TokyoGhoul_KaguneRetractedCells".Translate(pawn.LabelShort), pawn, MessageTypeDefOf.NegativeEvent);
                    pawn.health.RemoveHediff(this);
                    return;
                }

                // Потребляем немного RC-клеток за поддержку формы (например, 0.5% каждые 200 тиков)
                gene.Value -= 0.005f;

                // 3. Проверка на критический голод
                if (pawn.needs.food != null)
                {
                    // Если еда на нуле
                    if (pawn.needs.food.CurLevel <= 0f)
                    {
                        // Кагуне втягивается, так как нет энергии
                        Messages.Message("TokyoGhoul_KaguneRetractedStarvation".Translate(pawn.LabelShort), pawn, MessageTypeDefOf.NegativeEvent);
                        pawn.health.RemoveHediff(this);

                        // Шанс 25% сойти с ума от голода (Berserk), если кагуне "доело" последние силы
                        if (Rand.Value < 0.25f && !pawn.InMentalState)
                        {
                            pawn.mindState.mentalStateHandler.TryStartMentalState(MentalStateDefOf.Berserk, "Голод гуля стал невыносимым");
                        }
                    }
                }
            }
        }
    }
}

/ClassLibrary1/IsGhoul.cs
========================================
﻿using Verse;
using RimWorld;

namespace TokyoGhoulMod
{
    public static class PawnExtensions
    {
        public static bool IsGhoul(this Pawn pawn)
        {
            if (pawn == null || pawn.genes == null)
                return false;

            bool result = pawn.genes.Xenotype == GhoulDefOf.TG_Ghoul;
            return result;
        }
    }
}

/ClassLibrary1/ModInit.cs
========================================
﻿using Verse;
using HarmonyLib;
using System.Reflection;

namespace TokyoGhoulMod
{
    [StaticConstructorOnStartup]
    public static class TokyoGhoul_PostInit
    {
        static TokyoGhoul_PostInit()
        {
            // Создаем экземпляр Harmony с уникальным ID
            var harmony = new Harmony("kirinyamaga.tokyoghoul");

            // Выполняем патчи
            harmony.PatchAll(Assembly.GetExecutingAssembly());

            Log.Message("[Tokyo Ghoul] Harmony patches applied successfully.");
        }
    }
}

/ClassLibrary1/Patch_Ingested.cs
========================================
﻿using HarmonyLib;
using RimWorld;
using Verse;
using Verse.AI;

namespace TokyoGhoulMod
{
    [HarmonyPatch(typeof(Thing), "Ingested")]
    public static class Patch_Ingested
    {
        // В Префиксе мы только подменяем число питательности на 0
        [HarmonyPrefix]
        public static bool Prefix(Thing __instance, Pawn ingester, ref float __result)
        {
            if (ingester?.genes == null) return true;

            Gene_RCCells gene = ingester.genes.GetFirstGeneOfType<Gene_RCCells>();
            if (gene == null) return true;

            // Если это обычная еда (не человечина)
            if (!IsHumanlikeMeat(__instance) && IsNormalFood(__instance))
            {
                // Принудительно ставим результат в 0, чтобы шкала голода не росла
                __result = 0f;
            }

            return true;
        }

        // В Постфиксе мы начисляем RC-клетки ИЛИ вызываем рвоту
        [HarmonyPostfix]
        public static void Postfix(Thing __instance, Pawn ingester, ref float __result)
        {
            if (ingester?.genes == null) return;
            Gene_RCCells gene = ingester.genes.GetFirstGeneOfType<Gene_RCCells>();
            if (gene == null) return;

            if (IsHumanlikeMeat(__instance))
            {
                float nutritionValue = __instance.def.ingestible?.CachedNutrition ?? 0.1f;
                // Начисляем RC-клетки: 1 единица питания = 0.5 шкалы RC
                gene.Value += nutritionValue * 0.5f;
            }
            else if (IsNormalFood(__instance))
            {
                // Вместо мгновенного прерывания джоба, добавляем хедифф отравления
                // Рвота произойдет сама из-за FoodPoisoning или через HediffComp_Vomit
                ingester.health.AddHediff(HediffDefOf.FoodPoisoning, null, null);

                // Сбрасываем уровень еды обратно (наказание за обычную еду)
                if (ingester.needs.food != null)
                {
                    ingester.needs.food.CurLevel -= __result; // Отнимаем то, что он только что съел
                }
                __result = 0f;

                Messages.Message("TokyoGhoul_GhoulsCantEatNormalFood".Translate(), ingester, MessageTypeDefOf.NegativeEvent);
            }
        }

        private static bool IsHumanlikeMeat(Thing food)
        {
            // Проверка на уничтоженный объект (безопасность)
            if (food == null) return false;

            if (food.def == ThingDefOf.Meat_Human) return true;
            if (food is Corpse corpse && corpse.InnerPawn.RaceProps.Humanlike) return true;

            CompIngredients ingredients = food.TryGetComp<CompIngredients>();
            if (ingredients != null)
            {
                return ingredients.ingredients.Contains(ThingDefOf.Meat_Human);
            }
            return false;
        }

        private static bool IsNormalFood(Thing food)
        {
            if (food?.def?.ingestible == null) return false;
            FoodTypeFlags flags = food.def.ingestible.foodType;

            return flags.HasFlag(FoodTypeFlags.VegetableOrFruit) ||
                   flags.HasFlag(FoodTypeFlags.Meat) ||
                   flags.HasFlag(FoodTypeFlags.AnimalProduct) ||
                   flags.HasFlag(FoodTypeFlags.Meal) ||
                   flags.HasFlag(FoodTypeFlags.Processed) ||
                   flags.HasFlag(FoodTypeFlags.Liquor) ||
                   flags.HasFlag(FoodTypeFlags.Fungus);
        }

        private static void ApplyGhoulishRejection(Pawn pawn)
        {
            // Просто добавляем работу рвоты в очередь или запускаем её.
            // На этом этапе предмет уже "съеден" и удален, ошибки не будет.
            Job vomitJob = JobMaker.MakeJob(JobDefOf.Vomit);
            pawn.jobs.StartJob(vomitJob, JobCondition.InterruptForced, null, true);

            pawn.health.AddHediff(HediffDefOf.FoodPoisoning, null, null);
            Messages.Message("Гули не могут переваривать обычную пищу!", pawn, MessageTypeDefOf.NegativeEvent);
        }
    }
}

/ClassLibrary1/PawnRenderNode_Kagune.cs
========================================
﻿using Verse;
using RimWorld;
using UnityEngine;
using System.Linq;

namespace TokyoGhoulMod
{
    // 1. Свойства: Добавляем поле kaguneTag для использования в XML
    public class PawnRenderNodeProperties_Kagune : PawnRenderNodeProperties
    {
        public string kaguneTag; // Ukaku, Koukaku, Rinkaku, Bikaku

        public PawnRenderNodeProperties_Kagune()
        {
            nodeClass = typeof(PawnRenderNode_Kagune);
            workerClass = typeof(PawnRenderNodeWorker_Kagune);
        }
    }

    // 2. Worker: Логика отрисовки
    public class PawnRenderNodeWorker_Kagune : PawnRenderNodeWorker
    {
        public override bool CanDrawNow(PawnRenderNode node, PawnDrawParms parms)
        {
            if (!base.CanDrawNow(node, parms)) return false;

            Pawn pawn = node.tree?.pawn;
            if (pawn?.health?.hediffSet == null) return false;

            // ИСПРАВЛЕНИЕ: Используем Props с большой буквы
            var kaguneProps = node.Props as PawnRenderNodeProperties_Kagune;

            if (kaguneProps == null || string.IsNullOrEmpty(kaguneProps.kaguneTag))
                return false;

            // Ищем хедифф: Hediff_ + тег (например, Hediff_Ukaku)
            string requiredHediffName = "Hediff_" + kaguneProps.kaguneTag;

            // Проверяем наличие хедиффа в списке
            return pawn.health.hediffSet.hediffs.Any(x => x.def.defName == requiredHediffName);
        }
    }

    // 3. Узел
    public class PawnRenderNode_Kagune : PawnRenderNode
    {
        public PawnRenderNode_Kagune(Pawn pawn, PawnRenderNodeProperties props, PawnRenderTree tree)
            : base(pawn, props, tree) { }
    }
}

/ClassLibrary1/ThoughtWorker_Precept_Ghoul_Social.cs
========================================
﻿using Verse;
using RimWorld;


namespace TokyoGhoulMod
{
    //Наследуем ThoughtWorker_Precept_Social для возможности изменения отношений 
    public class ThoughtWorker_Precept_Ghoul_Social : RimWorld.ThoughtWorker_Precept_Social
    {
        //Проверяем наличие на карте пешек с необходимым условием
        protected override ThoughtState ShouldHaveThought(Pawn p, Pawn otherPawn)
        {
            //Находим пешку с геном гуля
            return otherPawn.IsGhoul();
        }
    }
}

