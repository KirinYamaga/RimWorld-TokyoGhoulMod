/ClassLibrary1/Ability_ToggleKagune.cs
========================================
﻿using RimWorld;
using Verse;
using System.Linq;

namespace TokyoGhoulMod
{
    public class Ability_ToggleKagune : Ability
    {
        public Ability_ToggleKagune() : base() { }
        public Ability_ToggleKagune(Pawn pawn) : base(pawn) { }
        public Ability_ToggleKagune(Pawn pawn, AbilityDef def) : base(pawn, def) { }

        public override bool Activate(LocalTargetInfo target, LocalTargetInfo dest)
        {
            base.Activate(target, dest);

            // Определяем тип (например, Ukaku) из названия способности
            string typeTag = this.def.defName.Replace("Release_", "");
            HediffDef kaguneHediffDef = DefDatabase<HediffDef>.GetNamed("Hediff_" + typeTag, false);

            if (kaguneHediffDef == null) return false;

            Hediff existing = pawn.health.hediffSet.GetFirstHediffOfDef(kaguneHediffDef);

            if (existing != null)
            {
                // Если кагуне этого типа уже активно — убираем его
                pawn.health.RemoveHediff(existing);
                Messages.Message("TokyoGhoul_KaguneRetracted".Translate(pawn.LabelShort), pawn, MessageTypeDefOf.SilentInput);
            }
            else
            {
                // ХИМЕРА: Мы БОЛЬШЕ НЕ вызываем RemoveExistingKagunes.
                // Просто добавляем новое кагуне к уже имеющимся.
                pawn.health.AddHediff(kaguneHediffDef);

                if (pawn.Map != null)
                    FleckMaker.ThrowMetaIcon(pawn.Position, pawn.Map, FleckDefOf.PsycastAreaEffect);

                Messages.Message("TG_KaguneReleased".Translate(pawn.LabelShort, kaguneHediffDef.label), MessageTypeDefOf.PositiveEvent);
            }

            if (pawn.meleeVerbs != null) pawn.meleeVerbs.Notify_PawnDespawned();
            pawn.Drawer.renderer.SetAllGraphicsDirty();

            return true;
        }

        public override AcceptanceReport CanCast
        {
            get
            {
                AcceptanceReport report = base.CanCast;
                if (!report.Accepted) return report;

                // Уточняем: нужно иметь какухо именно того типа, который мы пытаемся выпустить
                string typeTag = this.def.defName.Replace("Release_", "");
                HediffDef requiredKakuho = DefDatabase<HediffDef>.GetNamed("Hediff_Kakuho" + typeTag, false);

                if (requiredKakuho == null || !pawn.health.hediffSet.HasHediff(requiredKakuho))
                {
                    return new AcceptanceReport("TG_MissingSpecificKakuho".Translate(typeTag));
                }

                return true;
            }
        }
    }
}

/ClassLibrary1/Ability_UkakuFire.cs
========================================
﻿using RimWorld;
using Verse;
using UnityEngine;

namespace TokyoGhoulMod
{
    public class Ability_UkakuFire : Ability
    {
        public Ability_UkakuFire() : base() { }
        public Ability_UkakuFire(Pawn pawn) : base(pawn) { }
        public Ability_UkakuFire(Pawn pawn, AbilityDef def) : base(pawn, def) { }
        public Ability_UkakuFire(Pawn pawn, Precept sourcePrecept, AbilityDef def) : base(pawn, sourcePrecept, def) { }

        public override AcceptanceReport CanCast
        {
            get
            {
                AcceptanceReport report = base.CanCast;
                if (!report.Accepted) return report;

                // ИСПРАВЛЕНО: Проверка наличия хедиффа Укаку через ключ локализации
                if (!pawn.health.hediffSet.HasHediff(HediffDef.Named("Hediff_Ukaku")))
                    return new AcceptanceReport("TG_NeedUkaku".Translate());

                // ИСПРАВЛЕНО: Проверка запаса RC-клеток через ключ локализации
                Gene_RCCells gene = pawn.genes?.GetFirstGeneOfType<Gene_RCCells>();
                if (gene == null || gene.Value < 0.02f)
                    return new AcceptanceReport("TG_LowRCCells".Translate());

                return true;
            }
        }

        public override bool Activate(LocalTargetInfo target, LocalTargetInfo dest)
        {
            Gene_RCCells gene = pawn.genes?.GetFirstGeneOfType<Gene_RCCells>();
            if (gene != null)
            {
                gene.Value -= 0.02f;
            }

            ShootProjectile(target);
            return base.Activate(target, dest);
        }

        private void ShootProjectile(LocalTargetInfo target)
        {
            if (pawn.Map == null || !target.IsValid) return;

            ThingDef projectileDef = this.def.verbProperties.defaultProjectile;
            if (projectileDef == null) return;

            Projectile projectile = (Projectile)GenSpawn.Spawn(projectileDef, pawn.Position, pawn.Map);
            Vector3 targetVec = target.CenterVector3;

            targetVec.x += Rand.Range(-0.3f, 0.3f);
            targetVec.z += Rand.Range(-0.3f, 0.3f);

            LocalTargetInfo finalTarget = new LocalTargetInfo(targetVec.ToIntVec3());

            projectile.Launch(
                pawn,
                pawn.DrawPos,
                finalTarget,
                target,
                ProjectileHitFlags.All,
                false,
                null
            );
        }
    }
}

/ClassLibrary1/Alert_RCStarvation.cs
========================================
﻿using System.Collections.Generic;
using RimWorld;
using Verse;

namespace TokyoGhoulMod
{
    public class Alert_RCStarvation : Alert
    {
        public Alert_RCStarvation()
        {
            this.defaultLabel = "TG_AlertRCStarvationLabel".Translate();
            this.defaultExplanation = "TG_AlertRCStarvationDesc".Translate();
            this.defaultPriority = AlertPriority.Critical;
        }

        public override AlertReport GetReport()
        {
            return AlertReport.CulpritsAre(GhoulsInDanger);
        }

        private List<Pawn> GhoulsInDanger
        {
            get
            {
                List<Pawn> culprits = new List<Pawn>();

                // Используем AllMapsCaravansAndTravellingTransporters_Alive_FreeColonists из вашего PawnsFinder
                var candidates = PawnsFinder.AllMapsCaravansAndTravellingTransporters_Alive_FreeColonists;

                foreach (Pawn p in candidates)
                {
                    if (p.genes == null) continue;
                    Gene_RCCells gene = p.genes.GetFirstGeneOfType<Gene_RCCells>();

                    if (gene != null && gene.Value < 0.05f)
                    {
                        culprits.Add(p);
                    }
                }
                return culprits;
            }
        }
    }
}

/ClassLibrary1/GeneGizmo_RCCells.cs
========================================
﻿using RimWorld;
using Verse;
using UnityEngine;
using System.Collections.Generic;

namespace TokyoGhoulMod
{
    public class GeneGizmo_RCCells : GeneGizmo_Resource
    {
        // Конструктор, принимающий 4 параметра
        public GeneGizmo_RCCells(Gene_Resource gene, List<IGeneResourceDrain> drainDefs, Color barColor, Color barHighlightColor)
            : base(gene, drainDefs, barColor, barHighlightColor)
        {
        }

        // Обязательные поля для слайдеров в 1.6
        protected override bool DraggingBar { get; set; }

        protected override string GetTooltip()
        {
            return "TG_RCCellsDesc".Translate();
        }
    }
}

/ClassLibrary1/GeneticsHelper.cs
========================================
﻿using RimWorld;
using Verse;
using System.Linq;
using UnityEngine;

namespace TokyoGhoulMod
{
    public static class GeneticsHelper
    {
        public static void InitializeGhoulishTraits(Pawn pawn)
        {
            if (pawn?.genes == null) return;

            Pawn father = pawn.GetFather();
            Pawn mother = pawn.GetMother();

            if (father != null || mother != null)
            {
                ApplyInheritance(pawn, father, mother);
            }
            else
            {
                // Если родителей нет в мире (спавн рейдера или старт игры)
                AssignRandomTraits(pawn);
            }
        }

        private static void ApplyInheritance(Pawn child, Pawn father, Pawn mother)
        {
            // --- 1. НАСЛЕДОВАНИЕ ЦВЕТА ---
            if (!HasColorGene(child))
            {
                GeneDef fColor = GetActiveKaguneColorGene(father);
                GeneDef mColor = GetActiveKaguneColorGene(mother);

                if (fColor != null && mColor != null && fColor != mColor)
                {
                    float rand = Rand.Value;
                    if (rand < 0.40f)
                    {
                        Color blended = (GetColorFromGene(fColor) + GetColorFromGene(mColor)) / 2f;
                        AddGeneAsInheritable(child, FindClosestColorGene(blended));
                    }
                    else AddGeneAsInheritable(child, rand < 0.70f ? fColor : mColor);
                }
                else if (fColor != null || mColor != null)
                {
                    AddGeneAsInheritable(child, fColor ?? mColor);
                }
            }

            // --- 2. НАСЛЕДОВАНИЕ ТИПА ---
            if (!HasTypeGene(child))
            {
                GeneDef fType = GetActiveKaguneTypeGene(father);
                GeneDef mType = GetActiveKaguneTypeGene(mother);

                if (fType != null && mType != null)
                {
                    if (fType != mType)
                    {
                        if (Rand.Value < 0.15f) // Шанс на Химеру
                        {
                            AddGeneAsInheritable(child, fType);
                            AddGeneAsInheritable(child, mType);

                            // ГЛАВНОЕ ИЗМЕНЕНИЕ: Устанавливаем имя ксенотипа
                            child.genes.xenotypeName = "TG_ChimeraXenotypeLabel".Translate();

                            Messages.Message("TG_ChimeraBorn".Translate(child.LabelShort), child, MessageTypeDefOf.PositiveEvent);
                        }
                        else
                        {
                            AddGeneAsInheritable(child, Rand.Value < 0.5f ? fType : mType);
                        }
                    }
                    else
                    {
                        AddGeneAsInheritable(child, fType);
                    }
                }
            }
        }

        private static void AssignRandomTraits(Pawn pawn)
        {
            // Даем случайный цвет
            if (!HasColorGene(pawn))
                AddGeneAsInheritable(pawn, GetRandomColorGene());

            // Даем случайный тип (для рейдеров/стартовых)
            if (!HasTypeGene(pawn))
            {
                string[] types = { "Ukaku", "Koukaku", "Rinkaku", "Bikaku" };
                GeneDef randomType = DefDatabase<GeneDef>.GetNamed("Gene_" + types.RandomElement(), false);
                if (randomType != null) AddGeneAsInheritable(pawn, randomType);
            }
        }

        private static void AddGeneAsInheritable(Pawn pawn, GeneDef geneDef)
        {
            if (geneDef == null || pawn.genes.HasActiveGene(geneDef)) return;
            pawn.genes.AddGene(geneDef, xenogene: false);
        }

        private static bool HasColorGene(Pawn p) => p.genes.GenesListForReading.Any(g => g.def.exclusionTags != null && g.def.exclusionTags.Contains("KaguneColor"));

        // ВАЖНО: Проверяем наличие любого из 4 генов типа
        private static bool HasTypeGene(Pawn p)
        {
            string[] types = { "Gene_Ukaku", "Gene_Koukaku", "Gene_Rinkaku", "Gene_Bikaku" };
            return p.genes.GenesListForReading.Any(g => types.Contains(g.def.defName));
        }

        private static GeneDef GetRandomColorGene() => DefDatabase<GeneDef>.AllDefs.Where(g => g.exclusionTags != null && g.exclusionTags.Contains("KaguneColor")).RandomElement();

        private static GeneDef GetActiveKaguneColorGene(Pawn p) => p?.genes?.GenesListForReading.FirstOrDefault(g => g.Active && g.def.exclusionTags != null && g.def.exclusionTags.Contains("KaguneColor"))?.def;

        private static GeneDef GetActiveKaguneTypeGene(Pawn p)
        {
            string[] types = { "Gene_Ukaku", "Gene_Koukaku", "Gene_Rinkaku", "Gene_Bikaku" };
            return p?.genes?.GenesListForReading.FirstOrDefault(g => g.Active && types.Contains(g.def.defName))?.def;
        }

        private static Color GetColorFromGene(GeneDef gene) => gene.renderNodeProperties?.FirstOrDefault()?.color ?? Color.red;

        private static GeneDef FindClosestColorGene(Color target)
        {
            GeneDef closest = null;
            float minDistance = float.MaxValue;
            var colorGenes = DefDatabase<GeneDef>.AllDefs.Where(g => g.exclusionTags != null && g.exclusionTags.Contains("KaguneColor"));
            foreach (var g in colorGenes)
            {
                Color c = GetColorFromGene(g);
                float distance = Mathf.Sqrt(Mathf.Pow(c.r - target.r, 2) + Mathf.Pow(c.g - target.g, 2) + Mathf.Pow(c.b - target.b, 2));
                if (distance < minDistance) { minDistance = distance; closest = g; }
            }
            return closest ?? colorGenes.First();
        }
    }
}

/ClassLibrary1/Gene_RCCells.cs
========================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using RimWorld;
using UnityEngine;
using Verse;
using Verse.AI;

namespace TokyoGhoulMod
{
    public class Gene_RCCells : Gene_Resource
    {
        // Базовые параметры расхода
        private const float DaysToStarve = 15f;
        private const float PassiveDrainPerDay = 1f / DaysToStarve;
        private const float KaguneDrainMultiplier = 15f;
        private const float UkakuDrainMultiplier = 25f;

        private const float ThresholdHungerLight = 0.30f;
        private const float ThresholdHungerCritical = 0.05f;

        public float cannibalismCount = 0f;

        public override float InitialResourceMax => 1f;
        protected override Color BarColor => new Color(0.75f, 0f, 0f);
        protected override Color BarHighlightColor => new Color(1f, 0.2f, 0.2f);
        public override float MinLevelForAlert => 0.15f;
        public override string ResourceLabel => "TG_RCCellsLabel".Translate();

        public override void ExposeData()
        {
            base.ExposeData();
            Scribe_Values.Look(ref cannibalismCount, "cannibalismCount", 0f);
        }

        public void ConsumeGhoulMatter(float nutrition)
        {
            cannibalismCount += nutrition;
            Value += nutrition * 0.8f;
            if (cannibalismCount > 20f && pawn.IsHashIntervalTick(2500))
                Messages.Message("TG_KakujaStirring".Translate(pawn.LabelShort), pawn, MessageTypeDefOf.CautionInput);
        }

        public override IEnumerable<Gizmo> GetGizmos()
        {
            foreach (Gizmo gizmo in base.GetGizmos())
                if (!(gizmo is GeneGizmo_Resource)) yield return gizmo;
            if (pawn.IsColonistPlayerControlled)
                yield return new GeneGizmo_RCCells(this, null, BarColor, BarHighlightColor);
        }

        public override void Tick()
        {
            base.Tick();
            if (!pawn.Spawned || pawn.Dead) return;

            // Считаем количество активных боевых форм кагуне
            int activeKaguneCount = CountActiveKagunes();
            bool anyActive = activeKaguneCount > 0;

            if (pawn.IsHashIntervalTick(100))
            {
                ManageKakugan(anyActive);

                float currentMultiplier = PassiveDrainPerDay;
                if (anyActive)
                {
                    bool isUkaku = pawn.health.hediffSet.HasHediff(DefDatabase<HediffDef>.GetNamed("Hediff_Ukaku", false));
                    float baseActiveDrain = isUkaku ? UkakuDrainMultiplier : KaguneDrainMultiplier;

                    // БАЛАНС ХИМЕРЫ: Каждое дополнительное кагуне увеличивает расход на 70%
                    currentMultiplier *= baseActiveDrain * (1f + (activeKaguneCount - 1) * 0.7f);
                }

                Value -= (currentMultiplier / 60000f) * 100f;
                UpdateStatusEffects(anyActive);
                UpdateRCStarvationHediff();
            }

            if (pawn.needs.food != null && !anyActive)
                pawn.needs.food.CurLevel += pawn.needs.food.FoodFallPerTick * 0.95f;
        }

        private int CountActiveKagunes()
        {
            string[] tags = { "Hediff_Ukaku", "Hediff_Koukaku", "Hediff_Rinkaku", "Hediff_Bikaku" };
            return pawn.health.hediffSet.hediffs.Count(h => tags.Contains(h.def.defName));
        }

        // Остальные методы (UpdateRCStarvationHediff, ApplyStarvationDamage, ManageKakugan) остаются без изменений
        // ... (пропускаю для краткости, они должны быть в коде)

        private void UpdateRCStarvationHediff()
        {
            HediffDef starvationDef = DefDatabase<HediffDef>.GetNamed("RCStarvation", false);
            if (starvationDef == null) return;
            Hediff existing = pawn.health.hediffSet.GetFirstHediffOfDef(starvationDef);
            if (Value < ThresholdHungerLight)
            {
                if (existing == null) existing = pawn.health.AddHediff(starvationDef);
                existing.Severity = 1.0f - (Value / ThresholdHungerLight);
                if (Value < ThresholdHungerCritical && !pawn.InMentalState && !pawn.Downed && Rand.Value < 0.05f)
                    pawn.mindState.mentalStateHandler.TryStartMentalState(MentalStateDefOf.Berserk, "TG_GhoulHungerReason".Translate(), true);
                if (Value <= 0.001f && existing.Severity >= 0.95f) ApplyStarvationDamage();
            }
            else if (existing != null)
            {
                existing.Severity -= 0.05f;
                if (existing.Severity <= 0) pawn.health.RemoveHediff(existing);
            }
        }

        private void ApplyStarvationDamage()
        {
            if (pawn.jobs?.curJob != null && (pawn.jobs.curJob.def == JobDefOf.LayDown || pawn.jobs.curJob.def == JobDefOf.Wait_MaintainPosture))
                pawn.jobs.EndCurrentJob(JobCondition.InterruptForced);
            pawn.TakeDamage(new DamageInfo(DamageDefOf.Stab, 1.2f, 0, -1, null, pawn.RaceProps.body.corePart));
            if (pawn.IsHashIntervalTick(1000))
                Messages.Message("TG_GhoulStarvingToDeath".Translate(pawn.LabelShort), pawn, MessageTypeDefOf.NegativeHealthEvent);
        }

        private void UpdateStatusEffects(bool isKaguneActive)
        {
            if (Value <= 0 && isKaguneActive)
            {
                string[] tags = { "Hediff_Ukaku", "Hediff_Koukaku", "Hediff_Rinkaku", "Hediff_Bikaku" };
                var toRemove = pawn.health.hediffSet.hediffs.Where(h => tags.Contains(h.def.defName)).ToList();
                foreach (var h in toRemove) pawn.health.RemoveHediff(h);
                Messages.Message("TokyoGhoul_KaguneRetractedCells".Translate(pawn.LabelShort), pawn, MessageTypeDefOf.NegativeEvent);
                pawn.Drawer.renderer.SetAllGraphicsDirty();
            }
        }

        private void ManageKakugan(bool isKaguneActive)
        {
            HediffDef kakuganDef = DefDatabase<HediffDef>.GetNamed("Kakugan", false);
            if (kakuganDef == null) return;
            bool currentlyHas = pawn.health.hediffSet.HasHediff(kakuganDef);
            bool shouldHave = isKaguneActive || pawn.InMentalState;
            if (shouldHave && !currentlyHas)
            {
                var eyes = pawn.health.hediffSet.GetNotMissingParts().Where(p => p.def == BodyPartDefOf.Eye);
                foreach (var part in eyes) pawn.health.AddHediff(kakuganDef, part);
            }
            else if (!shouldHave && currentlyHas)
                pawn.health.hediffSet.hediffs.RemoveAll(x => x.def == kakuganDef);
        }

        public override void PostAdd()
        {
            base.PostAdd();
            Value = 0.5f;

            // 1. ЗАПУСК ГЕНЕТИКИ (Наследование или рандом)
            GeneticsHelper.InitializeGhoulishTraits(pawn);

            // 2. ВЫДАЧА ВСЕХ ОРГАНОВ КАКОХО ДЛЯ ХИМЕР
            string[] types = { "Ukaku", "Koukaku", "Rinkaku", "Bikaku" };
            foreach (var type in types)
            {
                GeneDef typeGene = DefDatabase<GeneDef>.GetNamed("Gene_" + type, false);
                if (pawn.genes.HasActiveGene(typeGene))
                {
                    HediffDef kakuhoDef = DefDatabase<HediffDef>.GetNamed("Hediff_Kakuho" + type, false);
                    // Добавляем орган, если его еще нет
                    if (kakuhoDef != null && !pawn.health.hediffSet.HasHediff(kakuhoDef))
                    {
                        pawn.health.AddHediff(kakuhoDef, pawn.RaceProps.body.corePart);
                    }
                }
            }
        }
    }
}

/ClassLibrary1/GhoulDefOf.cs
========================================
﻿using RimWorld;
using Verse;

namespace TokyoGhoulMod
{
    [DefOf]
    public static class GhoulDefOf
    {
        public static HediffDef TG_RinkakuKagune;

        public static XenotypeDef TG_Ghoul;

        static GhoulDefOf()
        {
            DefOfHelper.EnsureInitializedInCtor(typeof(GhoulDefOf));
        }
    }
}

/ClassLibrary1/IsGhoul.cs
========================================
﻿using Verse;
using RimWorld;

namespace TokyoGhoulMod
{
    public static class PawnExtensions
    {
        public static bool IsGhoul(this Pawn pawn)
        {
            if (pawn == null || pawn.genes == null)
                return false;

            bool result = pawn.genes.Xenotype == GhoulDefOf.TG_Ghoul;
            return result;
        }
    }
}

/ClassLibrary1/Mod.csproj
========================================
﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{5958758E-12CB-48C2-9319-CAEC7E2B7DB5}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>TokyoGhoulMod</RootNamespace>
    <AssemblyName>TokyoGhoulMod</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\..\TokyoGhoulRey\Assemblies\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Compile Include="Ability_ToggleKagune.cs" />
    <Compile Include="Ability_UkakuFire.cs" />
    <Compile Include="Alert_RCStarvation.cs" />
    <Compile Include="GeneGizmo_RCCells.cs" />
    <Compile Include="GeneticsHelper.cs" />
    <Compile Include="Gene_RCCells.cs" />
    <Compile Include="GhoulDefOf.cs" />
    <Compile Include="IsGhoul.cs" />
    <Compile Include="ModInit.cs" />
    <Compile Include="Patch_ButcherGhoul.cs" />
    <Compile Include="PawnRenderNode_Kagune.cs" />
    <Compile Include="Patch_Ingested.cs" />
    <Compile Include="PawnRenderNode_Single.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Recipe_KakuhoSurgery.cs" />
    <Compile Include="ThoughtWorker_RCStarvation.cs" />
  </ItemGroup>
  <ItemGroup>
    <Reference Include="0Harmony">
      <HintPath>..\..\..\HarmonyMod\Current\Assemblies\0Harmony.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="Assembly-CSharp">
      <HintPath>D:\Games\Steam\steamapps\common\RimWorld\RimWorldWin64_Data\Managed\Assembly-CSharp.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="UnityEngine">
      <HintPath>D:\Games\Steam\steamapps\common\RimWorld\RimWorldWin64_Data\Managed\UnityEngine.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="UnityEngine.CoreModule">
      <HintPath>D:\Games\Steam\steamapps\common\RimWorld\RimWorldWin64_Data\Managed\UnityEngine.CoreModule.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>

/ClassLibrary1/Mod.csproj.user
========================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <StartAction>Program</StartAction>
    <StartProgram>D:\Games\Steam\steamapps\common\RimWorld\RimWorldWin64.exe</StartProgram>
  </PropertyGroup>
</Project>

/ClassLibrary1/ModInit.cs
========================================
﻿using Verse;
using HarmonyLib;
using System.Reflection;

namespace TokyoGhoulMod
{
    [StaticConstructorOnStartup]
    public static class TokyoGhoul_PostInit
    {
        static TokyoGhoul_PostInit()
        {
            var harmony = new Harmony("kirinyamaga.tokyoghoul");
            harmony.PatchAll();
            Log.Message("[Tokyo Ghoul] Мод успешно инициализирован.");
        }
    }
}

/ClassLibrary1/Patch_ButcherGhoul.cs
========================================
﻿using HarmonyLib;
using RimWorld;
using Verse;
using System.Collections.Generic;
using System.Linq;

namespace TokyoGhoulMod
{
    [HarmonyPatch(typeof(Corpse), "ButcherProducts")]
    public static class Patch_ButcherGhoul
    {
        [HarmonyPostfix]
        public static void Postfix(Corpse __instance, ref IEnumerable<Thing> __result, Pawn butcher, float efficiency)
        {
            Pawn victim = __instance.InnerPawn;

            // Проверяем, является ли жертва гулем (наличие гена RC-клеток)
            if (victim?.genes == null || victim.genes.GetFirstGeneOfType<Gene_RCCells>() == null)
                return;

            List<Thing> products = __result.ToList();
            ThingDef ghoulMeatDef = DefDatabase<ThingDef>.GetNamed("Meat_Ghoul", false);

            if (ghoulMeatDef == null) return;

            // 1. Заменяем обычную человечину на мясо гуля
            for (int i = 0; i < products.Count; i++)
            {
                if (products[i].def == ThingDefOf.Meat_Human)
                {
                    int count = products[i].stackCount;
                    Thing newMeat = ThingMaker.MakeThing(ghoulMeatDef);
                    newMeat.stackCount = count;
                    products[i] = newMeat;
                }
            }

            // 2. Логика выпадения Какухо (Шанс 10%)
            if (Rand.Value < 0.10f)
            {
                string kakuhoType = GetKakuhoTypeFromPawn(victim);
                if (!string.IsNullOrEmpty(kakuhoType))
                {
                    // Собираем имя дефа предмета, например: Kakuho_Ukaku_Item
                    string itemDefName = "Kakuho_" + kakuhoType + "_Item";
                    ThingDef kakuhoItemDef = DefDatabase<ThingDef>.GetNamed(itemDefName, false);

                    if (kakuhoItemDef != null)
                    {
                        Thing kakuho = ThingMaker.MakeThing(kakuhoItemDef);
                        products.Add(kakuho);

                        // Сообщение игроку об удачной находке
                        Messages.Message("TG_KakuhoFoundDuringButchery".Translate(victim.LabelShort, kakuho.Label),
                            new LookTargets(__instance), MessageTypeDefOf.PositiveEvent);
                    }
                }
            }

            __result = products;
        }

        private static string GetKakuhoTypeFromPawn(Pawn p)
        {
            // Ищем хедифф какухо, чтобы понять тип
            if (p.health.hediffSet.HasHediff(DefDatabase<HediffDef>.GetNamed("Hediff_KakuhoUkaku", false))) return "Ukaku";
            if (p.health.hediffSet.HasHediff(DefDatabase<HediffDef>.GetNamed("Hediff_KakuhoKoukaku", false))) return "Koukaku";
            if (p.health.hediffSet.HasHediff(DefDatabase<HediffDef>.GetNamed("Hediff_KakuhoRinkaku", false))) return "Rinkaku";
            if (p.health.hediffSet.HasHediff(DefDatabase<HediffDef>.GetNamed("Hediff_KakuhoBikaku", false))) return "Bikaku";

            return null;
        }
    }
}

/ClassLibrary1/Patch_Ingested.cs
========================================
﻿using HarmonyLib;
using RimWorld;
using Verse;
using Verse.AI;
using System.Linq;

namespace TokyoGhoulMod
{
    [HarmonyPatch(typeof(Thing), "Ingested")]
    public static class Patch_Ingested
    {
        [HarmonyPrefix]
        public static bool Prefix(Thing __instance, Pawn ingester, ref float __result)
        {
            if (ingester?.genes == null) return true;
            if (ingester.genes.GetFirstGeneOfType<Gene_RCCells>() != null)
            {
                __result = 0f; // Гули живут на RC-клетках
            }
            return true;
        }

        [HarmonyPostfix]
        public static void Postfix(Thing __instance, Pawn ingester, ref float __result)
        {
            if (ingester == null || __instance == null) return;

            Gene_RCCells gene = ingester.genes?.GetFirstGeneOfType<Gene_RCCells>();
            float nutrition = __instance.GetStatValue(StatDefOf.Nutrition);

            // Человек ест гуля
            if (gene == null)
            {
                if (IsGhoulMatter(__instance)) ApplyRCSyndrome(ingester);
                return;
            }

            // Гуль ест
            if (IsGhoulMatter(__instance))
            {
                gene.ConsumeGhoulMatter(nutrition);
                HediffDef highDef = DefDatabase<HediffDef>.GetNamed("TG_GhoulCannibalHigh", false);
                if (highDef != null) ingester.health.AddHediff(highDef);
            }
            else if (IsHumanlikeMeat(__instance))
            {
                gene.Value += nutrition * 0.5f;
            }
            else if (IsNormalFood(__instance))
            {
                ApplyGhoulishRejection(ingester, nutrition);
            }
        }

        private static bool IsGhoulMatter(Thing food)
        {
            if (food.def.defName == "Meat_Ghoul") return true;
            if (food is Corpse corpse && corpse.InnerPawn != null)
                return corpse.InnerPawn.genes?.GetFirstGeneOfType<Gene_RCCells>() != null;

            CompIngredients ingredients = food.TryGetComp<CompIngredients>();
            return ingredients != null && ingredients.ingredients.Any(d => d.defName == "Meat_Ghoul");
        }

        private static bool IsHumanlikeMeat(Thing food)
        {
            if (food.def == ThingDefOf.Meat_Human) return true;
            if (food is Corpse corpse && corpse.InnerPawn != null)
                return corpse.InnerPawn.RaceProps.Humanlike;

            CompIngredients ingredients = food.TryGetComp<CompIngredients>();
            return ingredients != null && ingredients.ingredients.Contains(ThingDefOf.Meat_Human);
        }

        private static bool IsNormalFood(Thing food)
        {
            if (food?.def?.ingestible == null) return false;
            return !IsGhoulMatter(food) && !IsHumanlikeMeat(food);
        }

        private static void ApplyRCSyndrome(Pawn pawn)
        {
            HediffDef syndromeDef = DefDatabase<HediffDef>.GetNamed("TG_RCSyndrome", false);
            if (syndromeDef != null)
            {
                Hediff existing = pawn.health.hediffSet.GetFirstHediffOfDef(syndromeDef);
                if (existing != null) existing.Severity += 0.20f;
                else pawn.health.AddHediff(syndromeDef).Severity = 0.20f;
            }
            Messages.Message("TG_HumanAteGhoulMeat".Translate(pawn.LabelShort), pawn, MessageTypeDefOf.NegativeHealthEvent);
        }

        private static void ApplyGhoulishRejection(Pawn pawn, float nutrition)
        {
            pawn.health.AddHediff(HediffDefOf.FoodPoisoning);
            if (pawn.needs.food != null) pawn.needs.food.CurLevel -= nutrition;
            Messages.Message("TokyoGhoul_GhoulsCantEatNormalFood".Translate(), pawn, MessageTypeDefOf.NegativeEvent);
        }
    }
}

/ClassLibrary1/PawnRenderNode_Kagune.cs
========================================
﻿using Verse;
using RimWorld;
using UnityEngine;
using System.Linq;

namespace TokyoGhoulMod
{
    public class PawnRenderNodeProperties_Kagune : PawnRenderNodeProperties
    {
        public string kaguneTag;
        public float baseScale = 1f;

        public PawnRenderNodeProperties_Kagune()
        {
            nodeClass = typeof(PawnRenderNode_Kagune);
            workerClass = typeof(PawnRenderNodeWorker_Kagune);
        }
    }

    public class PawnRenderNodeWorker_Kagune : PawnRenderNodeWorker
    {
        public override bool CanDrawNow(PawnRenderNode node, PawnDrawParms parms)
        {
            if (!base.CanDrawNow(node, parms)) return false;
            Pawn pawn = node.tree?.pawn;
            if (pawn?.health?.hediffSet == null) return false;

            var kaguneProps = node.Props as PawnRenderNodeProperties_Kagune;
            if (kaguneProps == null || string.IsNullOrEmpty(kaguneProps.kaguneTag)) return false;

            string requiredHediffName = "Hediff_" + kaguneProps.kaguneTag;
            return pawn.health.hediffSet.hediffs.Any(x => x.def.defName == requiredHediffName);
        }

        public override Vector3 ScaleFor(PawnRenderNode node, PawnDrawParms parms)
        {
            Vector3 result = base.ScaleFor(node, parms);
            if (node.Props is PawnRenderNodeProperties_Kagune props) result *= props.baseScale;
            return result;
        }
    }

    public class PawnRenderNode_Kagune : PawnRenderNode
    {
        public PawnRenderNode_Kagune(Pawn pawn, PawnRenderNodeProperties props, PawnRenderTree tree)
            : base(pawn, props, tree) { }

        public override Color ColorFor(Pawn pawn)
        {
            if (pawn.genes != null)
            {
                // ИСПРАВЛЕНО: Проверяем g.Active, чтобы учитывать систему доминирования генов
                Gene colorGene = pawn.genes.GenesListForReading.FirstOrDefault(g =>
                    g.Active &&
                    g.def.exclusionTags != null &&
                    g.def.exclusionTags.Contains("KaguneColor"));

                if (colorGene != null && colorGene.def.renderNodeProperties != null)
                {
                    var colorProp = colorGene.def.renderNodeProperties.FirstOrDefault();
                    if (colorProp != null && colorProp.color.HasValue)
                    {
                        return colorProp.color.Value;
                    }
                }
            }
            return new Color(0.8f, 0.1f, 0.1f); // Дефолтный красный
        }
    }
}

/ClassLibrary1/PawnRenderNode_Single.cs
========================================
﻿using Verse;
using RimWorld;
using UnityEngine;

namespace TokyoGhoulMod
{
    // Свойства
    public class PawnRenderNodeProperties_Single : PawnRenderNodeProperties
    {
        public float baseScale = 1f; // Поле для XML

        public PawnRenderNodeProperties_Single()
        {
            nodeClass = typeof(PawnRenderNode_Single);
            workerClass = typeof(PawnRenderNodeWorker_Single);
        }
    }

    // Воркер
    public class PawnRenderNodeWorker_Single : PawnRenderNodeWorker_Eye
    {
        public override Vector3 ScaleFor(PawnRenderNode node, PawnDrawParms parms)
        {
            // Возвращаем стандартный масштаб глаз (воркер глаза сам делает их маленькими)
            return base.ScaleFor(node, parms);
        }
    }

    // Узел
    public class PawnRenderNode_Single : PawnRenderNode
    {
        public PawnRenderNode_Single(Pawn pawn, PawnRenderNodeProperties props, PawnRenderTree tree)
            : base(pawn, props, tree) { }

        public override Graphic GraphicFor(Pawn pawn)
        {
            string text = TexPathFor(pawn);
            if (text.NullOrEmpty()) return null;

            float scale = 1f;
            // ПРОВЕРКА: Пытаемся достать масштаб из свойств
            if (props is PawnRenderNodeProperties_Single customProps)
            {
                scale = customProps.baseScale;
            }

            // Устанавливаем размер графики (drawSize) на основе нашего масштаба
            // Именно это значение физически уменьшит текстуру внутри игры
            return GraphicDatabase.Get<Graphic_Single>(text, ShaderFor(pawn), new Vector2(scale, scale), ColorFor(pawn));
        }
    }
}

/ClassLibrary1/Recipe_KakuhoSurgery.cs
========================================
﻿using System.Collections.Generic;
using System.Linq;
using RimWorld;
using Verse;

namespace TokyoGhoulMod
{
    public class Recipe_InstallKakuho : Recipe_InstallImplant
    {
        public override void ApplyOnPawn(Pawn pawn, BodyPartRecord part, Pawn billDoer, List<Thing> ingredients, Bill bill)
        {
            base.ApplyOnPawn(pawn, part, billDoer, ingredients, bill);
            if (pawn.genes == null) return;

            GeneDef ghoulBio = DefDatabase<GeneDef>.GetNamed("Gene_RCCells", false);
            if (ghoulBio != null && !pawn.genes.HasActiveGene(ghoulBio))
            {
                pawn.genes.AddGene(ghoulBio, true);
            }

            // Ищем тип по названию рецепта (например InstallKakuhoUkaku)
            string type = "";
            if (recipe.defName.Contains("Ukaku")) type = "Ukaku";
            else if (recipe.defName.Contains("Koukaku")) type = "Koukaku";
            else if (recipe.defName.Contains("Rinkaku")) type = "Rinkaku";
            else if (recipe.defName.Contains("Bikaku")) type = "Bikaku";

            if (!string.IsNullOrEmpty(type))
            {
                GeneDef kaguneGene = DefDatabase<GeneDef>.GetNamed("Gene_" + type, false);
                if (kaguneGene != null && !pawn.genes.HasActiveGene(kaguneGene))
                {
                    pawn.genes.AddGene(kaguneGene, true);
                }
            }
        }
    }

    public class Recipe_RemoveKakuho : RecipeWorker
    {
        public override IEnumerable<BodyPartRecord> GetPartsToApplyOn(Pawn pawn, RecipeDef recipe)
        {
            return pawn.health.hediffSet.hediffs
                .Where(h => h.def.defName.Contains("Kakuho"))
                .Select(h => h.Part)
                .Distinct();
        }

        public override void ApplyOnPawn(Pawn pawn, BodyPartRecord part, Pawn billDoer, List<Thing> ingredients, Bill bill)
        {
            Hediff kakuho = pawn.health.hediffSet.hediffs.FirstOrDefault(h => h.Part == part && h.def.defName.Contains("Kakuho"));

            if (kakuho != null)
            {
                string type = "";
                if (kakuho.def.defName.Contains("Ukaku")) type = "Ukaku";
                else if (kakuho.def.defName.Contains("Koukaku")) type = "Koukaku";
                else if (kakuho.def.defName.Contains("Rinkaku")) type = "Rinkaku";
                else if (kakuho.def.defName.Contains("Bikaku")) type = "Bikaku";

                // 1. УДАЛЯЕМ ГЕН ТИПА
                if (!string.IsNullOrEmpty(type))
                {
                    GeneDef geneDef = DefDatabase<GeneDef>.GetNamed("Gene_" + type, false);
                    if (geneDef != null)
                    {
                        Gene targetGene = pawn.genes?.GetGene(geneDef);
                        if (targetGene != null)
                        {
                            pawn.genes.RemoveGene(targetGene);
                        }
                    }
                }

                // 2. УДАЛЯЕМ БИОЛОГИЮ ГУЛЯ (Gene_RCCells)
                Gene bioGene = pawn.genes?.GetGene(DefDatabase<GeneDef>.GetNamed("Gene_RCCells", false));
                if (bioGene != null) pawn.genes.RemoveGene(bioGene);

                // 3. ВЫПАДЕНИЕ ПРЕДМЕТА
                string itemName = kakuho.def.defName + "_Item";
                if (itemName.Contains("Koukaku")) itemName = "Kakuho_Koukaku_Item";
                ThingDef itemDef = DefDatabase<ThingDef>.GetNamed(itemName, false) ?? DefDatabase<ThingDef>.GetNamed("Kakuho_Rinkaku_Item");

                if (pawn.Map != null)
                    GenPlace.TryPlaceThing(ThingMaker.MakeThing(itemDef), pawn.Position, pawn.Map, ThingPlaceMode.Near);

                pawn.health.RemoveHediff(kakuho);
                Messages.Message("TG_GhoulCured".Translate(pawn.LabelShort), pawn, MessageTypeDefOf.PositiveEvent);
            }
        }
    }
}

/ClassLibrary1/ThoughtWorker_RCStarvation.cs
========================================
﻿using RimWorld;
using Verse;

namespace TokyoGhoulMod
{
    public class ThoughtWorker_RCStarvation : ThoughtWorker
    {
        protected override ThoughtState CurrentStateInternal(Pawn p)
        {
            if (p.genes == null) return ThoughtState.Inactive;

            Gene_RCCells gene = p.genes.GetFirstGeneOfType<Gene_RCCells>();
            if (gene == null) return ThoughtState.Inactive;

            // Привязываем стадии мысли к уровню RC-клеток
            if (gene.Value < 0.05f) return ThoughtState.ActiveAtStage(2); // Критический
            if (gene.Value < 0.15f) return ThoughtState.ActiveAtStage(1); // Сильный
            if (gene.Value < 0.30f) return ThoughtState.ActiveAtStage(0); // Начальный

            return ThoughtState.Inactive;
        }
    }
}

/ClassLibrary1/.vs/Mod.csproj.dtbcache.json
========================================
{"RootPath":"E:\\TokyoGhoulRey\\RimWorld-TokyoGhoulMod\\ClassLibrary1\\ClassLibrary1","ProjectFileName":"Mod.csproj","Configuration":"Debug|AnyCPU","FrameworkPath":"","Sources":[{"SourceFile":"Ability_ToggleKagune.cs"},{"SourceFile":"Ability_UkakuFire.cs"},{"SourceFile":"GeneGizmo_RCCells.cs"},{"SourceFile":"Gene_RCCells.cs"},{"SourceFile":"GhoulDefOf.cs"},{"SourceFile":"IsGhoul.cs"},{"SourceFile":"ModInit.cs"},{"SourceFile":"PawnRenderNode_Kagune.cs"},{"SourceFile":"Patch_Ingested.cs"},{"SourceFile":"Properties\\AssemblyInfo.cs"},{"SourceFile":"Recipe_KakuhoSurgery.cs"},{"SourceFile":"ThoughtWorker_Precept_Ghoul_Social.cs"},{"SourceFile":"obj\\Debug\\.NETFramework,Version=v4.7.2.AssemblyAttributes.cs"}],"References":[{"Reference":"E:\\TokyoGhoulRey\\HarmonyMod\\Current\\Assemblies\\0Harmony.dll","ResolvedFrom":"","OriginalItemSpec":"","Name":"","EmbedInteropTypes":false,"CopyLocal":false,"IsProjectReference":false,"ProjectPath":""},{"Reference":"E:\\TokyoGhoulRey\\HarmonyMod\\Current\\Assemblies\\HarmonyMod.dll","ResolvedFrom":"","OriginalItemSpec":"","Name":"","EmbedInteropTypes":false,"CopyLocal":false,"IsProjectReference":false,"ProjectPath":""},{"Reference":"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7.2\\mscorlib.dll","ResolvedFrom":"","OriginalItemSpec":"","Name":"","EmbedInteropTypes":false,"CopyLocal":false,"IsProjectReference":false,"ProjectPath":""},{"Reference":"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7.2\\System.Core.dll","ResolvedFrom":"","OriginalItemSpec":"","Name":"","EmbedInteropTypes":false,"CopyLocal":false,"IsProjectReference":false,"ProjectPath":""}],"Analyzers":[],"Outputs":[{"OutputItemFullPath":"E:\\TokyoGhoulRey\\RimWorld-TokyoGhoulMod\\TokyoGhoulRey\\Assemblies\\ClassLibrary1.dll","OutputItemRelativePath":"ClassLibrary1.dll"},{"OutputItemFullPath":"","OutputItemRelativePath":""}],"CopyToOutputEntries":[]}

